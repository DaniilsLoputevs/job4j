//package ru.job4j.exam;
//
//public class Algorithms {
    /** Термины:
     * O >> Время выполнения итерации. (условная константа)
     * n >> Кол-во, итераций/элементов/проверок.
     * *Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций.
     * *По сути формула описывает, насколько быстро возрастает время выполнения алгоритма
     * с увеличением размера входных данных.
     *
     * Ниже перечислены пять разновидностей «О-большого», которые будут встречаться вам особенно часто,
     *  в порядке убывания скорости выполнения:
     *   O(log п ), или логарифмическое время. Пример: бинарный поиск.
     *   О(n), или линейное время. Пример: простой поиск.
     *   О(n * log п). Пример: эффективные алгоритмы сортировки (быстрая сортировка).
     *   О(n2). Пример: медленные алгоритмы сортировки (сортировка выборкой).
     *   О(n!). Пример: очень медленные алгоритмы (задача о коммивояжере).
     *
     *
     * Простой/Линейный/Тупой поиск (алгоритм)
     * Время: O(n) - Линейное время
     * Скорость роста: 1 к 1 с кол-во, Элементов.  100 = 100 >> 120 = 120
     * 100 элементов = 100 проверок
     * 4 000 000 000 элементов = 4 000 000 000 проверок
     *
     * + Можно проводить всегда и везде.
     * - Является не самым быстрым поиском.
     *
     *
     *
     * Бинарный поиск
     * Время: O(Log n) - логарифмическое время
     * Скорость роста: +1 итерация к удвоению кол-во, Элементов.  128 = 7 >> 256 = 8
     * - бинарное разделение всех имеющихся данных.
     * 100 элементов = 7 проверок
     * 4 000 000 000 элементов = 32 проверок
     *
     * + Краткий и быстрый
     * - ТОЛЬКО для сортированных "Массивов-Списков".
     *** Каждую итерацию сокращает границы поиска на 1/2(половину) от прошлой итерации,
     * при помощи знаков сравнения "<, >, =="
     * Пример:
     * 0     1     2      3       4   5    7        8         - Итерации
     * 100 - 50 - 25 - 12.5(13) - 6 - 3 - 1.5(2) - 0.75(1)    - Кол-во элементов в границе поиска.
     * Пример 2:
     * 0      1    2    3     4        5         6        7   - Итерации
     * 128 - 68 - 34 - 17 - 8.5(9) - 4.25(4) - 2.125(2) - 1   - Кол-во элементов в границе поиска.
     * ФИШКИ:
     ** Если кол-во элементов удваивается, то будет + 1 к итерации.
     ** Хорошо работает с чётным количеством элементов.
     *
     *
     *
     * Быстрая сортировка
     * Время: среднее: O(Log n) --- худшее: O(n)
     * - стратегия: Разделяй и Властвуй!
     * - РЕКУРСИЯ.
     * - бинарное разделение всех имеющихся данных. (как и в Бинарном поиске).
     *
     * «базовый случай» – самый простой случай который мы можем обработать.
     * * сортируем массив → рекурсия, разделяем задачу до получения «базового случая».
     * 1) выбираем «опорный элемент»(далее Оп. элемент) >>> далее, берём 2 под-массива(меньше и больше Оп. элемента)
     * 2) Рекурсивно выполняем для каждого под-массива.
     * (напоминает поиск по дереву: проверка меньше данного, идём в лево, больше -> в право)
     * 2) склеиваем по очереди: []меньше (Оп. Элемент) + Оп. Элемент + [](больше Оп. Элемент.) >>>
     * На выходе получаем готовый и отсортированный массив.
     *
     * ФИШКИ:
     *
     *
     *
     *
     *
     *
     *
     */
//}
